---
title: Redis参考03：分布式锁
author: fangkun119
date: 2025-07-10 12:00:00 +0800
categories: [中间件, Redis]
tags: [Redis]
pin: false
math: true
mermaid: true
image:
  path: /imgs/cover/redis.jpeg
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Responsive rendering of Chirpy theme on multiple devices.
---

{: .no_toc }

<details close markdown="block">
  <summary>
    目录
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>
单机 synchronized 会有分布式并发问题。

以分布式扣减库存场景为例，如果不能处理好分布式并发问题，就会出现超卖问题。

本文以该场景例，介绍 Redis 分布式锁，内容包括：

* Redis 分布式锁的实现原理
* Redison 分布式锁的使用
* Redison 分布式锁源码解读
* Redis 集群架构下锁失效问题及解决
* Redis 分布式锁并发度提升

## 1. 有问题的分布式锁

借助 Redis 的 SETNX 命令，仅当一个 Key 不存在时，才能执行成功。虽然下面的代码经过多轮修补，依然会有出现问题。见代码中 finally 块的注释。

```java
@RequestMapping("/deduct_stock")
public String deductStock() {
    // 商品的 key
    String lockKey = "lock:product_101";
    // 给 lock 设置的值是 client ID，用来在解锁时进行比较，试图组织“线程 A 给线程 B 解锁“这种情况
    String clientId = UUID.randomUUID().toString();
  	// 设置lockKey与设置超时时间，要放在一个原子操作里，通过超时时间来确保宕机也能解锁
    Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clientId, 10, TimeUnit.SECONDS); 	
    if (!result) {
        return "error_code";
    }

    try {
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); 
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + ""); 
            System.out.println("扣减成功，剩余库存:" + realStock);
        } else {
            System.out.println("扣减失败，库存不足");
        }
    } finally {
        // 发生“线程 B 给线程 A 解锁”的场景
        // 1. 当线程 A 执行时间超过过期时间时，Key 会被自动删除，导致锁失效
        // 2. 锁失效使线程 B 解除阻塞，扣减库存，并且进入到这个 finally 块，把还在运行的线程 A 的锁给解锁
        // 3. 线程 B 的解锁操作，使的线程 C 解除阻塞，进入到 finally 块，...
        // 4. 整个加锁解锁操作已经错乱 ....
        // 下面代码试图功过比较 client id，来避免”线程 B 给线程 A 解锁”，但依然有问题
        // 因为 “比较 client ID” 和 “解锁” 不在一个原子操作中
        // 1. 锁过期正好发生在线程 B 的两个操作之间
        // 2. 线程 A 正好执行了加锁操作（因为锁过期使得加锁成功）
        // 3. 线程 B 随后删除这个 Key，从而把线程 A 的锁给解锁了
        if (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))) {
            stringRedisTemplate.delete(lockKey);
        }
    }
    return "end";
}
```

## 2. 锁续期方案及实现

### 2.1. 锁续期介绍

锁续期：通俗讲，会有一个“线程”来定时给持有的锁续期，来避免锁超时释放，同时也能避免宕机导致死锁

* 如果机器没有宕机，锁续期，可以防止持有的锁，因为超时自动释放
* 如果机器发生宕机，那么没有线程来给锁续期，锁能够超时释放，避免死锁

锁续命的实现其实并不简单，但是有 Lib 提供了封装，例如 [Redisson](https://github.com/redisson/redisson)

### 2.2. 使用 Redisson 实现分布式锁

以库存扣减这样一个场景为例，演示使用 Redission 实现分布式锁

#### 2.2.1 引入依赖

引入依赖，除了使用 Redisson 分布式锁，也使用了 Spring Boot 提供的 Redission Template 来读写库存数据

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.6.5</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

#### 2.2.2 初始化 Redisson 客户端

组装 Redission Bean，然后就可以将这个 Bean 注入到使用它的地方

```java
import org.redisson.Redisson;
import org.redisson.config.Config;

@Bean
public Redisson redisson() {
	Config config = new Config();
	// 此为单机模式，也可改成主从模式/哨兵模式/集群模式
	config.useSingleServer().setAddress("redis://localhost:6379").setDatabase(0);
  // 可以设置锁续期超时时间，如果不设置，默认时 30 秒
  config.setLockWatchdogTimeout(10000);
	return (Redisson) Redisson.create(config);
}
```

#### 2.2.3 使用分布式锁实现库存扣减

注入 Redission Bean 之后，就可以使用 Redission 提供的分布式锁来完成库存扣减

```java
@RequestMapping("/deduct_stock")
public String deductStock() {
    String lockKey = "lock:product_101";
    // 获取锁对象
    RLock redissonLock = redisson.getLock(lockKey);
    // 加分布式锁
    redissonLock.lock();
    try {
      	// 执行库存扣减
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); 
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + ""); 
            System.out.println("扣减成功，剩余库存:" + realStock);
        } else {
            System.out.println("扣减失败，库存不足");
        }
    } finally {
        // 解锁
        redissonLock.unlock();
    }
    return "end";
}
```

## 3. Redisson 分布式锁源码解读

上面例子的代码入口：`RLock` 的 `lock()` 方法，RLock 的实现类是 RedissonLock

### 3.1 代码入口：RedissionLock.lock() 

```java
@Override
public void lock() {
    try {
        lockInterruptibly();
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}

@Override
public void lockInterruptibly() throws InterruptedException {
    lockInterruptibly(-1, null);
}
```

### 3.2 加锁操作：Redisson.tryLockInnerAsync(...)

从代码入口开始沿着调用链往下点：

```text
   RedissonLock.lockInterruptibly()
-> RedissonLock.lockInterruptibly(long leaseTime, TimeUnit unit)
-> RedissonLock.tryAcquire(long leaseTime, TimeUnit unit, long threadId)
-> RedissonLock.tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) 
-> RedissonLock.tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) 
```

找到下面的方法，给它添加了注释便于理解

```java
<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
    internalLockLeaseTime = unit.toMillis(leaseTime);
    // LUA 脚本的参数来自代码底部的 singletonList 
		// KEYS[1] : 值来自 getName()，代表加锁的 KEY，在这个例子中就是商品 ID "lock:product:101"
    // ARGV[1] : 值来自 internalLockLeaseTime，代表 KEY 的过期时间
    // ARGV[2] : 值来自 getLockName(threadId)，代表加锁的线程，值为 {UUID}:{thread_id}
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
							// 如果 KEY 不存在，
							// 1. 执行 hset 命令，让 KEY 指向一个 Hash，向 Hash 中存入 {UUID}:{thread_id} = 1
							// 2. 给该 KEY 设置超时时间
							// 说明：
							// (1) {UUID}:{thread_id}代表时谁加的锁；
							// (2) 值为 1 是给锁重入用的；
							// (3) 超时时间是从外面一路传进来的 leaseTime，默认 30 秒，可以在初始化 Redisson 时修改
              "if (redis.call('exists', KEYS[1]) == 0) then " +
                  "redis.call('hset', KEYS[1], ARGV[2], 1); " +
                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
									// Java 方法返回 null
                  "return nil; " +
              "end; " +
							// 如果 KEY 所代表的 Hash 存在，{UUID}:{thread_id} 也存在于这个 Hash 中
							// (1) 给 {UUID}:{thread_id} 对应的值加 1，表示锁重入
							// (2) 给 KEY 重新设置超时时间，以续期
              "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                  "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                  // Java 方法返回 null
                  "return nil; " +
              "end; " +
              // Java 方法返回 Key 的 ttl
              "return redis.call('pttl', KEYS[1]);",
              Collections.<Object>singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
}
```

### 3.3 锁续期： RedissonLock.tryAcquireAsync(...)

沿调用链返回向上一层：

```text
   RedissonLock.lockInterruptibly()
-> RedissonLock.lockInterruptibly(long leaseTime, TimeUnit unit)
-> RedissonLock.tryAcquire(long leaseTime, TimeUnit unit, long threadId)
-> RedissonLock.tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) 
```

找到这个方法： `RedissonLock.tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) `

这个是锁续命的入口方法，给它添加了注释便于理解

```java
private <T> RFuture<Long> tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) {
  	// 这是指定了生命期的加锁，忽略它（它不需要续期，加锁时设置好生命期就可以）。
    if (leaseTime != -1) {
        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    }
    // 没指定生命期的加锁，需要锁续期（直到加锁线程把锁释放，或者宕机不再续期、生命期耗尽）
    // 这里加锁是一个异步调用
    RFuture<Long> ttlRemainingFuture = tryLockInnerAsync(
        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),                     TimeUnit.MILLISECONDS, 
        threadId, 
        RedisCommands.EVAL_LONG);
    // 给这个异步调用设置监听器
    ttlRemainingFuture.addListener(new FutureListener<Long>() {
        // 上面的异步调用执行完毕时被回调
        @Override
        public void operationComplete(Future<Long> future) throws Exception {
            // 加锁失败，方法直接返回
            if (!future.isSuccess()) {
                return;
            }
						// 加锁成功
            Long ttlRemaining = future.getNow();
            if (ttlRemaining == null) {
              	// 创建一个定时任务进行锁续命
                scheduleExpirationRenewal(threadId);
            }
        }
    });
    return ttlRemainingFuture;
}
```

再看执行锁续期操作的方法：`RedissonLock.scheduleExpirationRenewal(...)`

```java
private void scheduleExpirationRenewal(final long threadId) {
    if (expirationRenewalMap.containsKey(getEntryName())) {
        return;
    }
    // 设置一个 TimerTask，它会在过期时间走到 1/3 ，即internalLockLeaseTime / 3 时执行
    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
        @Override
        public void run(Timeout timeout) throws Exception {
            
            RFuture<Boolean> future = commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                    // LUA 脚本的参数来自代码底部的 singletonList，取值见代码注释 
                    // 如果加锁的线程设置的那把锁还在，就更新它的过期时间，给它续期
                    "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                        "return 1; " +
                    "end; " +
                    "return 0;",
                    Collections.<Object>singletonList(
                        getName()), 					 // KEYS[1]: 加锁的 KEY，本例是商品ID "lock:product:101"
                        internalLockLeaseTime, // ARGV[1]: KEY 的过期时间
                        getLockName(threadId)  // ARGV[2]: 加锁线程，值为{UUID}:{thread_id}
                    );
            // 锁续期之后，再嵌套的设置一个 Event Listener，用于触发下一次锁续期
            // 相比于 JDK Timer， 这样的方法更加轻量级
            future.addListener(new FutureListener<Boolean>() {
                @Override
                public void operationComplete(Future<Boolean> future) throws Exception {
                    expirationRenewalMap.remove(getEntryName());
                    if (!future.isSuccess()) {
                        log.error("Can't update lock " + getName() + " expiration", future.cause());
                        return;
                    }
                    
                    if (future.getNow()) {
                        // reschedule itself
                        scheduleExpirationRenewal(threadId);
                    }
                }
            });
        }
    }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);

    if (expirationRenewalMap.putIfAbsent(getEntryName(), task) != null) {
        task.cancel();
    }
}
```

### 3.4 等待锁释放： RedissonLock.tryAcquireAsync(...)

沿调用链继续向上返回到第二层

```text
   RedissonLock.lockInterruptibly()
-> RedissonLock.lockInterruptibly(long leaseTime, TimeUnit unit)
```

代码入口：`RedissonLock.lockInterruptibly(long leaseTime, TimeUnit unit)`

```java
    @Override
    public void lockInterruptibly() throws InterruptedException {
        lockInterruptibly(-1, null);
    }

    @Override
    public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {
        // 准备
        long threadId = Thread.currentThread().getId();
        
        // 尝试加锁，返回的 ttl，
        // 它的值来自上面 3.2 小节的 tryLockInnerAsync 方法
        // 调用链 tryAcquire -> tryAcquireAsync -> tryLockInnerAsync
        // * null : 加锁成功
        // * >=0  : 锁被其它线程占有，但是设置了存活时间，返回的是剩余存活时间
        // * <0   : 锁被其它线程占有，但是无限持有，没有设存活时间（理论上不会出现这种情况）
        Long ttl = tryAcquire(leaseTime, unit, threadId);

        // 线程成功获得锁
        if (ttl == null) {
            return;
        }

        // 没有获得锁，订阅 Redis 的原生 Channel 用来接收加锁线程的解锁信息
        RFuture<RedissonLockEntry> future = subscribe(threadId);
        commandExecutor.syncSubscription(future);

        try {
            // 轮询，循环内部被阻塞，不会占用 CPU
            while (true) {
                // 尝试加锁成功，结束轮询（如果leaseTime 为-1，会用 watchDog 的超时时间来调用）
                ttl = tryAcquire(leaseTime, unit, threadId);
                if (ttl == null) {
                    // 不再轮询
                    break;
                }
								
                if (ttl >= 0) {
                    // 如果锁被其它线程占有且设置了存活时间 ttl，订阅 Channl 阻塞 ttl 这么久
                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } else {
                    // 如果锁被其它线程占有且没设存活时间（理论上不会发生）
                    getEntry(threadId).getLatch().acquire();
                }
            }
        } finally {
            // 解除 Channel 订阅
            unsubscribe(future, threadId);
        }
    }
```

订阅 Channel 的代码如下

```java
protected RFuture<RedissonLockEntry> subscribe(long threadId) {
  	// document: https://redis.io/docs/latest/commands/subscribe/
    return PUBSUB.subscribe(
        getEntryName(),   // 值为：{UUID}:{lock_name}
        getChannelName(), // 解锁通知的 Channel，值为："redission_lock__channel":{lock_name}
        commandExecutor.getConnectionManager().getSubscribeService());
}
```

接下来一个问题，Redis Channel 是如何像等待加锁的线程发送通知的呢？ 就要看接下来的解锁逻辑了

### 3.5 解锁线程发送消息：`unlockInnerAsync(...)`

顺着下面的调用链，可以找到进行解锁的方法

```text
   Redission.unlock()
-> Redission.unlockInnerAsync(long threadId)
```

给这个方法加了注释，便于理解

```java
protected RFuture<Boolean> unlockInnerAsync(long threadId) {
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
						// Lua 脚本参数定义在底部的Arrays.<Object>asList，具体含义见代码注释
            // 情况1：锁不存在，直接向 Channel 发送 Unlock Message
            "if (redis.call('exists', KEYS[1]) == 0) then " +
                "redis.call('publish', KEYS[2], ARGV[1]); " +
                "return 1; " +
            "end;" +
            // 情况 2：锁不是自己加的，直接返回，不做任何操作
            "if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then " +
                "return nil;" +
            "end; " +
            // 锁自己加的，重入次数减 1
            "local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); " +
            // 情况 3：重入次数减 1 后仍然大于 0 ，不解锁，只重置过期时间
            "if (counter > 0) then " +
                "redis.call('pexpire', KEYS[1], ARGV[2]); " +
                "return 0; " +
            // 情况 4：重入次数减 1 后变成 0，解锁（删除 KEY），向 Channel 发布 Unlock Message
            "else " +
                "redis.call('del', KEYS[1]); " +
                "redis.call('publish', KEYS[2], ARGV[1]); " +
                "return 1; "+
            "end; " +
            "return nil;",
            Arrays.<Object>asList(
                getName(),                // KEYS[1]: 加锁的 KEY，本例是商品ID "lock:product:101"
                getChannelName()),        // KEYS[2]: 解锁通知的 Channel，值为："redission_lock__channel":{lock_name}
                LockPubSub.unlockMessage, // ARGV[1]: 锁重入次数
                internalLockLeaseTime,    // ARGV[2]: KEY 的过期时间
                getLockName(threadId)     // ARGV[3]: 加锁线程，值为{UUID}:{thread_id}
            );
}
```

### 3.6 等待锁的线程接收消息

沿着加锁的调用量找到对应的代码。

```java
   RedissonLock.lockInterruptibly()
-> RedissonLock.lockInterruptibly(long leaseTime, TimeUnit unit)
```

这个方法会订阅消息、也会阻塞等待消息。

```java
@Override
public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {
    long threadId = Thread.currentThread().getId();
    Long ttl = tryAcquire(leaseTime, unit, threadId);
    if (ttl == null) {
        return;
    }

		// 订阅消息
    RFuture<RedissonLockEntry> future = subscribe(threadId);
    commandExecutor.syncSubscription(future);
    try {
        while (true) {
            ttl = tryAcquire(leaseTime, unit, threadId);
            if (ttl == null) {
                break;
            }
            // 阻塞等待消息
            if (ttl >= 0) {
                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
            } else {
                getEntry(threadId).getLatch().acquire();
            }
        }
    } finally {
        unsubscribe(future, threadId);
    }
}
```

订阅消息会通过 Redison 的 `LockPubSub extends PublishSubscribe` 来实现。

```java
protected static final LockPubSub PUBSUB = new LockPubSub();

protected RFuture<RedissonLockEntry> subscribe(long threadId) {
    return PUBSUB.subscribe(getEntryName(), getChannelName(), commandExecutor.getConnectionManager().getSubscribeService());
}
```

该方法会在订阅消息的同时注册下面的回调函数（具体调用链是 `PublishSubscribe.subribe` -> `PublishSubscribe.createListener` -> `LockPubSub.onMessage`) ，收到解锁通知时通过该回调方法来解除阻塞。具体的实现原理需要分析 LockPubSub 的源码，后面单独研究。

```java
@Override
protected void onMessage(RedissonLockEntry value, Long message) {
    // 如果消息的值是 0，就是3.5 代码“情况 4”中解锁线程向 Channel 发送的 0
    if (message.equals(unlockMessage)) {
        // 就会通过 value.getLatch() 获得信号量，通过 release 来释放
        value.getLatch().release();

        while (true) {
            Runnable runnableToExecute = null;
            synchronized (value) {
                Runnable runnable = value.getListeners().poll();
                if (runnable != null) {
                    if (value.getLatch().tryAcquire()) {
                        runnableToExecute = runnable;
                    } else {
                        value.addListener(runnable);
                    }
                }
            }
            
            if (runnableToExecute != null) {
                runnableToExecute.run();
            } else {
                return;
            }
        }
    }
}
```

一个问题：如果解锁消息丢失怎么办？例如占有锁的线程没有发送解锁通知、或者通知在网络上丢失了没有达到，那么等待获取锁的线程是否会永远阻塞？

答案是不会，从 3.4 小节的代码可以看出，lockInterruptibly 中每次 tryAcquire 都设置了阻塞时间，不会无限等待，然后当锁到期（或者其它线程获得再释放锁时）就又能得到锁（或接到解锁消息）

## 4 集群架构下锁失效问题

### 4.1 问题描述

在集群架构下，主节点向从节点同步数据是异步的。

主节点宕机时，加锁的 Key 如果还没有同步到从节点，从节点被选举为新的主节点，这个 Key 就会丢失，导致锁失效。

### 4.2 错误方法

#### 4.2.1 红锁（Red Lock）只能减少问题发生的概率

##### (1) 红锁的实现方式

1. Java Client 向所有节点执行 SETNX 进行加锁，半数以上成功才算执行成功（当一半的节点都执行完 SETNX 之后，另一个线程在正常情况下，无法再获得超过半数的节点）
2. 这样虽然增加了一点点等待，但是一致性更好

##### (2) 红锁的问题

红锁只能减少问题发生的概率，但并不能 100% 解决问题

**问题 1：锁丢失问题**

假定 Java Client 向 3 个 Redis 主节点执行 SETNX 进行加锁

线程 1：向 Node 1 和 Node 2 执行 SETNX，然后 Node 2 在同步完成之前宕机，Node 2 的从节点成为主节点，锁丢失

线程 2：向 Node 2 和 Node 3 执行 SETNX（对同一个 Key），因为 Node 2 的锁丢失，使得 SETNX 成功

**问题 2：不设置从节点也不能完全解决问题**

如果不设置从节点、只有三个主节点呢？

当 3 个主节点中有两个宕机时，客户端就无法加锁

为了减少这个问题发生的概率，需要更多的节点，代价是更低的性能

**问题 3： 设置宽松的持久化（例如 1 分钟持久化一次）也会有问题**

依然是上面的例子，3 个节点。

假设节点 2 ，在持久化完成之前，虚拟机重启，重启后，Redis 锁丢失。

这是另一个线程来加锁，依然可能会因为节点 2 的锁丢失，而加锁成功

#### 4.2.2 Fencing Token不能解决（容易与存储层记录锁租约Fencing 混淆）

##### (1) 原理

Fencing Token （栅栏 Token）是一个严格自增的 Token。在实现中，它是嵌套在分布式锁内的，一个线程首先需要获取分布式锁，然后再获取一个 Token，只有这个 Token 大于上一次执行的 Token 时，才会容许执行。

##### (2) 实现

例如通过 Redisson 的 AtomicLong.incrementAndGet 来生成一个自增 Token

```java
// 把 token 作为参数传给下游，下游用 token 做版本/幂等校验
long token = redisson.getAtomicLong("order:" + orderId + ":seq").incrementAndGet();
```

如果不能容忍主从切换带偶尔的 Token 回退（Token 自增操作丢失）

可通过 Redis 配置让 Token 自增至少同步到一个从节点，使 Token 自增不受主节点宕机影响（但这会把整个 Redis 从异步变成半同步，影响其它操作的性能，并不推荐）

```text
min-replicas-to-write 1
min-replicas-max-lag 5
```

另一方法是自己手写 LUA 脚本让 Redis 执行，等待 token 自增同步到至少 1 个从节点

```java
@Component
public class FencingTokenGenerator {
    private final RedissonClient redisson;
    private final int waitReplicas = 1;    // 至少 1 个从节点 ACK
    private final long waitTimeout = 5000; // 最多等 5 秒

    public FencingTokenGenerator(RedissonClient redisson) {
        this.redisson = redisson;
    }

    public long next(String bizId) {
        String key = "fencing:" + bizId;
        String lua =
            "local v = redis.call('INCR', KEYS[1]); " +
            "redis.call('WAIT', ARGV[1], ARGV[2]); " +
            "return v;";
        RScript script = redisson.getScript(StringCodec.INSTANCE);
        return script.eval(
                RScript.Mode.READ_WRITE,
                lua,
                RScript.ReturnType.INTEGER,
                Collections.singletonList(key),
                waitReplicas, waitTimeout
        );
    }
}
```

##### (3) 能阻止拿到过期锁的客户端执行写请求

如下面的例子

| 时间 | 客户端  | 动作                            | Token | last\_token | 结果                        |
| ---- | ------- | ------------------------------- | ----- | ----------- | --------------------------- |
| t0   | —       | —                               | —     | 0           | 初始                        |
| t1   | A       | 拿锁成功，token=100             | 100   | 0           | —                           |
| t2   | A       | 写请求：token=100               | 100   | 0           | **写成功**，last\_token←100 |
| t3   | A       | 进程 STW 10 s，锁已过期         | —     | 100         | 锁失效                      |
| t4   | B       | 拿锁成功，token=101             | 101   | 100         | —                           |
| t5   | A（旧） | **用过期锁**发写请求：token=100 | 100   | 100         | **拒绝写**（100 ≯ 100）     |
| t6   | B（新） | 写请求：token=101               | 101   | 100         | **写成功**，last\_token←101 |

##### (4) 不能防止主从切换导致的脏写

| 时间 | 客户端 | 动作                              | Token | last\_token | 备注                        |
| ---- | ------ | --------------------------------- | ----- | ----------- | --------------------------- |
| t0   | —      | —                                 | —     | 200         | 初始                        |
| t1   | A      | 在旧主拿锁成功，token=201         | 201   | 200         | 锁未同步到从节点            |
| t2   | 主崩溃 | 从晋升为新主                      | —     | 200         | 旧主数据未同步              |
| t3   | B      | 在新主**也能拿锁成功**，token=202 | 202   | 200         | 双主                        |
| t4   | A      | 写请求：token=201                 | 201   | 200         | **写成功**，last\_token←201 |
| t5   | B      | 写请求：token=202                 | 202   | 201         | **写成功**，last\_token←202 |

两个客户端都满足 `token > last_token`，都写入成功，脏写发生。

### 4.3 正确方法

业内实践采用 “业务兜底 + 锁弱化 + 容忍误判” 的方式，容忍锁的偶尔失效，把“互斥性”转嫁给业务幂等。下面是几种具体的方法，按照使用频率排序

#### 4.3.1 用业务幂等来兜底（最常用）

锁负责”大概率互斥“，线程拿到锁在执行业务之前，再检查一遍“是否已处理”，即利用幂等表来兜底。

这样即使锁丢失了，重复请求也会被幂等逻辑挡住，不会脏写。例如：

```sql
insert ignore into idempotent_log (biz_id, biz_type) values (123, 'pay');
```

优点：简单、吞吐高、完全兼容现有 Redis 主从

缺点：需要业务方写幂等代码，但是大多数业务本来就有幂等需求（支付、库存扣减等）

#### 4.3.2 存储层记录锁租约（Fencing）

##### (1) 例子演示

下面是一个例子，如果 Redison 分布式锁失效导致线程互斥失败时，只有一个线程的 Update SQL 能成功。

表结构

```sql
CREATE TABLE product_stock (
    id          BIGINT PRIMARY KEY,
    stock       INT    NOT NULL,
    lease_seq   BIGINT NOT NULL DEFAULT 0   -- 锁租约：每次成功扣减后 +1
);
INSERT INTO product_stock(id, stock, lease_seq) VALUES (1, 100, 0);
```

核心代码

```java
@Service
public class StockService {

    private final RedissonClient redisson;
    private final JdbcTemplate jdbc;

    public StockService(RedissonClient redisson, JdbcTemplate jdbc) {
        this.redisson = redisson;
        this.jdbc = jdbc;
    }

    /**
     * 扣库存
     * @param num 要扣的数量
     * @return true=成功
     */
    @Transactional
    public boolean deduct(long productId, int num) {
        RLock lock = redisson.getLock("stock:" + productId);

        // 1. 拿锁，最多等 5 秒，锁 10 秒后自动过期
        boolean locked = false;
        try {
            locked = lock.tryLock(5, 10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
        if (!locked) {
            return false; // 没抢到锁
        }

        try {
            // 2. 读取当前 lease_seq
            long lease = jdbc.queryForObject(
                    "SELECT lease_seq FROM product_stock WHERE id = ?",
                    Long.class, productId);

            // 3. 利用 lease_seq 做 CAS 更新
            int updated = jdbc.update(
                    "UPDATE product_stock " +
                    "SET stock = stock - ?, lease_seq = lease_seq + 1 " +
                    "WHERE id = ? AND lease_seq = ? AND stock >= ?",
                    num, productId, lease, num);

            return updated == 1; // 返回是否更新成功
        } finally {
            lock.unlock(); // 释放 Redisson 锁
        }
    }
}
```

它的关键是由存储层自己生成锁租约（Token）并有存储层检查。检查和更新锁租约是在同一个 UPDATE SQL 中通过原子操作来完成的。这样的 UPDAte SQL 如果并发执行，只有一个能成功。

##### (2) 存储层记录锁租约和 Fencing Token的差别

| 维度                     | 第一种（**客户端携带的单调 token**）                       | 第二种（**存储层记录的锁租约**）                             |
| ------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 叫什么                   | 通常就叫 “Fencing Token” 或 “Lamport token”                | 也叫 “Fencing”，但它是**存储层 CAS 的租约 ID**               |
| 生成者                   | 客户端自己（Redis `INCR` 或本地）                          | 存储层自己生成并记录（ZK zxid、etcd revision、DB 行版本）    |
| 校验者                   | 存储层比对 “客户端带来的 token > last\_token”              | 存储层比对 “客户端带来的租约 ID **等于**当前记录的租约 ID”   |
| 能否挡住主从切换时的脏写 | ❌ 不能，因为两个客户端都能拿到**更大**的 token，都通过检查 | ✅ 能，因为租约 ID 只有一个，**CAS 失败就拒绝**               |
| 典型实现                 | Redis `INCR` + 写 DB 时 if token > last\_token             | ZK `create -e -s` 的 sequence 节点、etcd `Txn().If(…).Then(…)`、MySQL `UPDATE … WHERE lease_id = ?` |

#### 4.3.3 “单线程队列”或“分区串行化”

例如

订单场景：订单维度分片 + 单线程消费：同一订单永远落在同一个 Kafka Partition 或 RocketMQ MessageQueue，天然串行。  

库存扣减场景：本地队列 + 批量提交，把并发压到 0。  

#### 4.3.4 用 Zookeeper、Etcd 或 Consul 

如果对一致性要求确实极端，不再用 Redis 主从，而是把分布式锁直接放在 **ZooKeeper、Etcd、Consul**，它们基于 **Raft/Paxos**，提供强一致性。

优点是：彻底消除主从切换带来的锁失效

缺点是：吞吐低于 Redis；部署、运维复杂度高于 Redis。

## 5 Redis分布式锁的并发度提升

对于极高并发的场景，优化思路如下

1. 降低锁粒度
2. 分段锁，例如 product 101 的 500 个库存，拆成 5 份，每份 100 个库存配一个分布式锁，这样并发量就增大了5 倍，Concurrent Hashmap 也借鉴了这个思路
3. 读写锁