---
title: Java并发编程01：设计模式   
author: fangkun119
date: 2025-10-02 12:00:00 +0800
categories: [Java, Java 并发编程]
tags: [Java, Java 并发编程]
pin: false
math: true
mermaid: true
image:
  path: /imgs/cover/java_concurrency.jpg
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: java concurrency
---

{: .no_toc }

<details close markdown="block">
  <summary>
    目录
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

本文共介绍了9种并发设计模式，按照用途分为四种：

1. 优雅终止：两阶段终止（Two Phases Termination）
2. 避免共享：不变对象（Immutable），写时复制（Copy On Write），线程本地存储（Thread Local）
3. 多线程版执行触发：守护挂起（Guarded Suspension），避免执行（Baking）
4. 多线程分工：Therad-Per-Message，工作线程（Worker Thread），生产者消费者模式

## 1. 优雅终止线程的设计模式

### 1.1 线程终止问题的提出

**在并发编程实践中，线程的安全终止是一个至关重要的问题。** 当一个线程T1需要优雅地终止另一个线程T2时，必须采用科学的方法来确保资源的正确释放和系统状态的完整性。

**基于深入的线程安全性分析，两阶段终止模式被证明是最有效的解决方案。** 这种模式能够在保证线程安全的同时，实现资源的有序清理。1.2 两阶段终止（Two-phase Termination）模式——优雅的终止线程

#### 1.2.1 模式基本概念

**两阶段终止模式是一种专门设计用于优雅终止线程的并发设计模式。** 该模式通过分阶段的方式实现线程的安全退出，避免了强制终止可能带来的各种问题。

**该模式的核心执行流程包含两个明确的阶段：**

* **第一阶段：** 向目标线程发送终止请求信号

* **第二阶段：** 等待线程完成当前执行并安全退出

**通过这种分阶段的执行方式，** 能够确保线程在接收到终止请求后，有机会完成必要的清理工作，从而维护系统的稳定性。

#### 1.2.2 Java线程中断机制分析

**在Java线程状态管理的框架下，** 深入理解线程中断机制对于实现两阶段终止模式具有重要意义。Java线程的生命周期中，线程可能处于多种状态，包括运行状态、休眠状态等。

**线程状态转换的关键机制包括：**

* **状态前提：** 线程进入终止状态的前提是必须先进入RUNNABLE状态，与之对应的是线程也可能在休眠状态。

* **中断机制：** 利用Java的interrupt()方法可以将线程从休眠状态唤醒并转换到RUNNABLE状态

* **优雅退出：** 当线程回到RUNNABLE状态后，就可以用设置标志位的方式，让线程在合适的时机自主完成run()方法的执行，实现优雅退出。

**基于这些机制的综合分析，** 终止指令的实现必须包含两个核心要素：interrupt()方法和线程终止标志位。这种组合方式能够应对各种线程状态下的终止需求。

#### 1.2.3 模式优势分析

**采用两阶段终止模式能够为并发系统带来显著的实际效益：**

1. **优雅终止：** 通过有序的终止流程，避免突然终止线程可能导致的副作用和系统不稳定
2. **安全保障：** 确保在线程终止前完成必要的资源清理工作，有效防止内存泄漏和数据丢失
3. **灵活配置：** 支持根据具体业务场景灵活设置终止条件和清理策略，提供良好的可扩展性

**这些优势共同构成了两阶段终止模式在并发编程中的重要价值。**

#### 1.2.4 基础实现示例

**实际开发实践当中，** 采用Java线程中断机制的实现方案具有明显优势，核心在于中断信号的传递和捕获机制和标志位。只需要向线程发送中断信号，线程就会自动捕获并响应，然后根据标志位决定是否跳出循环执行结构、完成清理操作并自主退出。

```java
public class MonitorThread2 extends Thread {
    // 在监控线程中加一个volatile类型的标志变量，用于标识是否需要终止线程
    private volatile boolean terminated = false;

    public void run() {
        while (!Thread.interrupted() && !terminated) {
            // 执行监控操作
            System.out.println("监控线程正在执行监控操作...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("监控线程被中断，准备退出...");
                Thread.currentThread().interrupt();
                e.printStackTrace();
            }
        }
        // 执行清理操作
        System.out.println("监控线程正在执行清理操作...");
        releaseResources();
    }
}
```

### 1.3 使用场景

**在实际的软件系统开发中，** 两阶段终止模式具有广泛的适用性和重要的应用价值。该模式特别适用于以下关键场景：

| 场景      | 说明                                        |
| :------ | :---------------------------------------- |
| 服务器应用程序 | 在需要处理大量并发请求的服务端环境中，确保服务停止时数据的完整保存和资源的正确释放 |
| 大规模并发系统 | 线程数量众多的复杂系统中，实现所有线程的协调关闭和资源的统一管理          |
| 定时任务系统  | 在定时执行的业务逻辑中，确保任务完成后线程的规范终止和相关资源的清理        |
| 数据处理系统  | 在批量数据处理场景中，保证所有数据处理完成后线程的安全退出             |
| 消息订阅系统  | 在消息处理完成后，确保订阅线程的正确终止和系统资源的及时释放            |

**从系统可靠性和可维护性的角度考量，** 两阶段终止模式为这些场景提供了稳定可靠的线程管理解决方案。在应用过程中，需要特别关注终止条件的合理设计和清理工作的完整性实现。

#### 1.3.1 两阶段模式优雅终止监控线程

**在需要长时间运行的监控系统中，** 两阶段终止模式为监控线程的安全退出提供了可靠的保障机制。监控线程通常需要持续执行轮询操作，因此其终止过程必须经过精心设计。

**通过应用两阶段终止模式，** 能够确保监控线程在接收到终止请求时能够安全地释放所有占用的资源并规范地退出执行。同时，该模式还保证了监控线程在终止前完成所有必要的清理工作，有效避免了资源泄漏和系统状态不一致等问题。

**具体而言，** 这种实现方式通过volatile类型的标志变量和interrupt()机制的协同作用，实现了线程的安全终止。

* 标志变量用于控制循环执行的终止。
* 中断机制则用于唤醒处于阻塞状态的线程。

下面是第一个版本的代码，它只使用了标志变量。当标志变量`terminated`为`true`时，线程当前一轮循环自然完成、或者被中断时，自然跳出循环，然后执行清理操作，优雅退出。

```java
public class MonitorThread extends Thread {
    //在监控线程中添加一个volatile类型的标志变量，用于标识是否需要终止线程的执行
    private volatile boolean terminated = false;

    public void run() {
        while (!terminated) {
            // 执行监控操作
            System.out.println("监控线程正在执行监控操作...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // 不让异常向外抛，它只是中断了sleep操作
                e.printStackTrace(); 
            }
        }
        // 执行清理操作
        System.out.println("监控线程正在执行清理操作...");
        releaseResources();
    }

    public void terminate() {  // 通过terminate方法来修改标志变量
        //设置标志变量为true，并等待一段时间
        terminated = true;
        try {
            join(5000); // 等待5秒钟,期间监控线程会检查terminated的状态
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void releaseResources() {
        // 释放资源和进行必要的清理工作
        System.out.println("监控线程正在释放资源和进行必要的清理工作...");
    }

    public static void main(String[] args) throws InterruptedException {
        MonitorThread thread = new MonitorThread();
        // 启动监控线程
        thread.start();
        // 主线程休眠期间，监控线程在执行监控操作
        Thread.sleep(10000);
        // 终止监控线程，这是自己写的方法，Thread类没有这个方法
        thread.terminate();
        Thread.sleep(100000);
    }
}
```

下面是第二个代码版本，它结合了标志变量和中断机制，两者中任何一个，都能促发线程的优雅终止。更加灵活和可靠，能够应对更复杂的线程状态和运行环境。

```java
public class MonitorThread2 extends Thread {
    //在监控线程中添加一个volatile类型的标志变量，用于标识是否需要终止线程的执行
    private volatile boolean terminated = false;

    public void run() {
        // 中断状态和terminated标志变量，任何一个都能结束while循环
        while (!Thread.interrupted() && !terminated) { 
            // 执行监控操作
            System.out.println("监控线程正在执行监控操作...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("监控线程被中断，准备退出...");
              	// 捕捉异常清除了中断状态，调用下面的代码，把中断信号加回来
                // 这样上层代码才能感知到这个中断状态，它有两种方法进行感知
                // 1. Thread.currentThread().isInterrupted(): 只感知不清除
                // 2. Thread.interrupted()：感知同时清除中断状态
                // 这里恢复状态，能够在terminated为true时让while循环结束
                Thread.currentThread().interrupt();  
                e.printStackTrace();
            }
        }
        // 执行清理操作
        System.out.println("监控线程正在执行清理操作...");
        releaseResources();
    }

    public void terminate() {
        //设置标志变量为true，并等待一段时间
        terminated = true;
        try {
            join(5000); // 等待5秒钟,期间监控线程会检查terminated的状态
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void releaseResources() {
        // 释放资源和进行必要的清理工作
        System.out.println("监控线程正在释放资源和进行必要的清理工作...");
    }

    public static void main(String[] args) throws InterruptedException {
        MonitorThread2 thread = new MonitorThread2();
        //启动监控线程
        thread.start();
        //主线程休眠期间，监控线程在执行监控操作
        Thread.sleep(10000);
        //向监控线程发送中断信号
        thread.interrupt();
        //设置监控线程的终止标志位（terminated）
        thread.terminate();
        //主线程先不要退出，继续演示监控线程的操作
        Thread.sleep(100000);
    }
}
```

这个版本的核心思想是同时利用两种机制的各自优势，构建更加完善的终止体系。

**要点包括：**

* **双重检查机制：** 同时检查中断状态和标志变量，确保任何一个都能终止线程，提高终止响应的准确性。
* **中断状态恢复：** 在捕获InterruptedException后重新设置中断状态，确保中断状态能传递到上一层的while循环检查点。

这种设计模式在实际应用中表现出更好的适应性和可靠性。

#### 1.3.2 优雅地终止线程池

**在现代Java应用程序开发中，** 线程池的使用已经成为并发编程的标准实践。相比手动创建和管理线程，线程池提供了更加高效和可控的资源管理机制。因此，理解如何优雅地终止线程池具有重要的实际意义。 Java线程池框架提供了两种核心的终止方法： shutdown() 和 shutdownNow()。

##### (1) shutdown()方法

**shutdown()方法采用渐进式的终止策略，** 其主要特点是停止接收新任务的同时，允许已提交任务的继续执行直到完成。这种方法适用于需要确保所有任务都得到处理的场景。

**从执行流程的角度分析，** shutdown()方法的运行机制包含以下关键步骤：

* **立即停止接收新任务：** 调用方法后，线程池不再接受新的任务提交

* **继续执行现有任务：** 队列中已存在的任务将继续得到执行

* **等待任务完成：** 正在执行的任务将继续运行直到完成

* **安全关闭：** 所有任务完成后，线程池自动关闭并释放资源

**这种终止方式的优点在于能够保证所有已提交任务的完整执行，缺点是关闭过程可能需要较长时间。**

##### (2) shutdownNow()方法

**相比之下，shutdownNow()方法采用更加激进和快速的终止策略。** 该方法不仅停止接收新任务，还会尝试中断正在执行的任务线程。

**根据方法的行为特征，** shutdownNow()方法的执行流程具有以下特点：

* **立即停止新任务：** 立即停止接收新的任务提交

* **中断执行中任务：** 通过interrupt()方法尝试中断正在执行任务的线程

* **返回未执行任务：** 将队列中尚未开始执行的任务作为列表返回

* **快速关闭：** 立即关闭线程池并释放资源

**需要注意的是，** 虽然shutdownNow()方法会尝试中断所有线程，但并不能保证所有线程都会被成功中断，因为线程的实现代码、可以选择忽略中断请求。

**在实际应用中，** 通常采用组合策略：首先调用shutdown()方法，等待一段时间后如果线程池仍未关闭，再调用shutdownNow()方法强制关闭剩余线程。

##### (3) 其他方法



### 1.4 注意事项

**作为一种在Java并发编程中广泛应用的设计模式，** 两阶段终止模式在实际使用中需要特别注意以下关键技术要点：

* **终止标志位的局限性：** 单纯依赖标志变量可能无法处理线程处于阻塞状态的情况，因此需要结合中断机制使用

* **中断机制的完整性要求：** 第三方类库可能没有正确处理中断异常，这可能导致线程无法正常终止。因此需要自定义终止标志位作为补充机制

* **线程池管理的规范性：** 在使用线程池时，必须严格遵循shutdown()和shutdownNow()方法的使用规范，特别是在使用shutdownNow()时需要格外谨慎

这些技术要点对于确保线程终止过程的可靠性和安全性具有重要的指导意义。

## 2. 避免共享的设计模式

**从并发编程的根本原理出发，** 线程安全问题的主要根源在于多个线程对共享资源的并发访问。为了从根本上解决这一问题，业界发展出了多种避免共享的设计模式。其中，不变性模式、写时复制模式和线程本地存储模式是最具代表性的三种解决方案。

* **使用不变性模式时需要特别注意**属性的不可变性保证

* **写时复制模式需要重点考虑**拷贝操作的性能开销

* **线程本地存储模式需要注意**异步执行环境下的特殊处理。

### 2.1 不变性（Immutability）模式——想破坏也破坏不了

#### 2.1.1 模式基本原理

**并发问题的本质在于共享资源的并发修改操作。** 当多个线程同时读写同一个共享变量时，就会出现并发安全问题。然而，如果共享变量只有读操作而没有写操作，那么并发安全问题就自然消失了。

**基于这一基本原理，** 不变性模式的核心思想是创建不可修改的对象。这种设计策略通过消除写操作来从根本上避免并发问题，是一种简单而有效的并发安全解决方案。

**从设计模式的角度定义，** 不变性模式是一种创建型设计模式，其核心特征是对象一旦创建完成，其状态就不能被修改。在多线程环境中使用不可变对象，能够自然地避免线程安全问题，同时还能提升程序的性能和可读性。

#### 2.1.2 模式优势分析

**采用不变性模式能够为并发系统带来多方面的显著优势：**

1. **内在的线程安全性：** 不可变对象天然具备线程安全特性，在多线程环境中使用时无需额外的同步机制，从而避免了同步操作带来的性能开销
2. **清晰的状态语义：** 由于对象状态在创建后保持不变，使得程序逻辑更加清晰易懂，有助于代码的理解和维护
3. **高效的缓存优化：** 不可变对象的稳定状态使其更适合进行缓存优化，能够显著提升程序执行效率
4. **便捷的单元测试：** 不可变对象的状态确定性使得单元测试更加简单可靠，有助于提高代码质量

#### 2.1.3 模式限制与注意事项

**尽管不变性模式具有众多优势，** 但在实际应用中也需要注意其固有的限制条件。不可变对象的主要限制在于其状态一旦创建就无法修改，这在需要频繁更新对象状态的场景中可能造成不便。

**具体而言，** 不变性模式的限制主要体现在以下几个方面：

* **对象重建成本：** 每次状态更新都需要创建新的对象实例，可能带来额外的内存和计算开销

* **内存占用增加：** 大量新对象的创建可能导致内存使用量的增加

* **引用关系处理：** 当不可变对象之间存在引用关系时，需要特别注意状态变化的传播和一致性维护

**在实际应用中，** 需要根据具体的使用场景来评估不变性模式的适用性，在性能要求和并发安全需求之间找到合适的平衡点。

### 2.2 使用场景

**不变性模式在实际软件开发中有着广泛的应用场景，** 特别是在需要确保对象状态稳定性和一致性的情况下。以下是一些典型的应用场景：

* **缓存系统实现：** 在缓存系统中，被缓存的数据通常需要保持不变，以避免并发访问导致的数据不一致问题。不变性模式能够有效保证缓存数据的安全性和稳定性

* **值对象设计：** 在领域驱动设计中，值对象（Value Object）通常要求具有不可变性，以确保其语义的一致性和可比较性

* **配置信息管理：** 系统配置信息通常在启动时确定，在运行期间保持不变。使用不变性模式能够确保配置信息的安全访问和一致性

**在这些应用场景中，** 不变性模式不仅解决了并发安全问题，还提供了更加清晰和可靠的代码结构。

#### 2.2.1 如何实现不变性模式

**不变性模式的实现遵循一套明确的规范和原则，** 其核心机制是通过严格的访问控制和状态管理来保证对象的不可变性。

**实现不变性模式的关键要素包括：**

* **属性访问控制：** 将所有类属性设置为**private**，防止外部直接访问和修改

* **属性不可变性：** 将所有类属性声明为**final**，确保其值在对象创建后无法修改

* **方法只读设计：** 所有类方法都设计为**只读方法**，不提供任何状态修改功能

* **防御性拷贝：** 对于可变对象的引用，采用**防御性拷贝**机制避免外部修改影响内部状态

**在Java标准库中，** 许多核心类都采用了不变性设计模式。例如，String类、Integer类、Long类、Double类等基础类型的包装类都具备完整的不可变性。这些类的线程安全性正是通过不变性机制来保证的。

**这些标准库实现严格遵循了不可变类的三项核心要求：**

* **类声明为final：** 防止子类继承和重写破坏不可变性

* **所有属性为final：** 确保属性值在创建后无法修改

* **所有方法为只读：** 不提供任何修改对象状态的方法

#### 2.2.2 使用 Immutability 模式的注意事项

**在实际应用不变性模式时，** 需要特别注意一些容易忽略的技术细节和潜在问题。这些注意事项对于确保不变性模式的有效性具有重要意义。

* **需要特别注意的是，** 即使对象的所有属性都声明为final，也不能完全保证对象的不可变性

* **同样重要的是，** 不可变对象的发布过程也需要特别关注，确保其在多线程环境中的正确可见性

**从Java语言特性的角度分析，** final关键字的作用范围存在一定的限制。当对象的属性类型为可变对象时，虽然引用本身不可修改，**但引用指向的对象内容仍然可以被修改**。这种情况下，对象的整体不变性就可能被破坏。

**下面的代码示例清楚地说明了这个问题：**

```java
class Foo{
    int age=0;
    String name="abc";
}

final class Bar {
    final Foo foo;

    void setAge(int a){
        foo.age=a;  // 虽然foo是final的，但其属性age仍然可以被修改
    }
}
```

**从线程安全的角度进一步分析，** 不可变对象本身虽然具备线程安全性，但这并不意味着持有不可变对象的引用也是线程安全的。**下面的演示将暴露这个问题**。

```java
//Foo线程安全
final class Foo{
    final int age=0;
    final String name="abc";
}

//Bar线程不安全
class Bar {
    Foo foo;

    void setFoo(Foo f){
        this.foo=f;  // foo引用的修改在多线程中不能保证原子性和可见性
    }
}
```

**因此，** 在使用不变性模式时，需要仔细分析对象间的引用关系，确保整个对象图的不可变性，而不仅仅是单个对象的不可变性。

### 2.3 写时复制（Copy-on-Write）模式

#### 2.3.1 模式介绍

**在多线程并发访问共享数据的场景中，** 写时复制模式提供了一种高效的并发性能优化方案。该模式通过延迟复制和按需复制的策略，有效地减少了写操作对读操作的影响。

**写时复制模式的核心执行流程如下：**

* **读操作：** 读操作直接访问`原始共享数据`，无需加锁，具有很高的性能

* **写操作触发：** 当需要进行写操作时，首先创建`原始共享数据`的完整`副本`

* **副本修改：** 在`副本`上执行所有的修改操作

* **原子替换：** 将修改后的`副本`原子地替换`原始共享数据`

**通过这种设计方式，** 写时复制模式避免了多个线程同时访问同一数据对象时的竞争和冲突问题。读操作完全无锁，写操作虽然有复制开销，但不会阻塞读操作。

**从应用范围的角度来看，** 写时复制模式在不可变对象的写操作中有着天然的应用优势。事实上，许多不可变对象的更新操作都是基于写时复制机制实现的。

**在Java语言中，** 基础数据类型如String、Integer、Long等都是基于写时复制方案实现的。这种设计的巧妙之处在于，通过写时复制机制，既保证了对象的不可变性，又提供了合理的性能表现。

**从性能分析的角度来看，** 写时复制模式的主要缺点在于**内存消耗**。每次写操作都需要创建新的对象副本，这在高频写操作的场景下可能导致显著的内存开销。然而，随着现代垃圾回收算法的成熟和硬件性能的提升，这种内存消耗的代价已经大大降低。

**因此，** 在读多写少的典型应用场景中，写时复制模式是一个值得考虑的优化方案。

#### 2.3.2 使用场景

**Java标准库中提供了两个经典的写时复制容器实现：** CopyOnWriteArrayList和CopyOnWriteArraySet。这两个容器充分体现了写时复制模式的设计思想和优势特点。

**以CopyOnWriteArrayList为例，** 该容器的读操作完全无锁，具有极高的并发读取性能。当需要进行写操作时，容器会创建内部数组的完整副本，在副本上完成所有修改操作，最后将新的数组原子地替换原有数组。

**这种设计特别适用于以下场景：**

* **读操作远多于写操作：** 如配置信息管理、监听器列表管理等

* **数据量相对较小：** 避免大对象复制带来的性能开销

* **对写操作的延迟容忍：** 写操作的性能开销可以被接受

**在操作系统领域，** 写时复制技术有着同样重要的应用。以Linux系统的fork()系统调用为例，传统的进程创建需要完整复制父进程的地址空间，这是一个非常耗时的操作。

**Linux通过写时复制优化了这一过程：**

* **共享地址空间：** 子进程创建时与父进程共享相同的地址空间

* **按需复制：** 只有当父进程或子进程需要进行写操作时，才会复制相应的内存页

* **独立地址空间：** 复制完成后，父子进程拥有各自独立的地址空间

**这种优化大大提高了进程创建的效率，** 是写时复制模式在系统层面的成功应用。

**在函数式编程领域，** 写时复制模式更是发挥着基础性作用。函数式编程的核心原则是不可变性，所有的数据修改操作都需要通过创建新对象来实现。写时复制模式为函数式编程提供了高效的数据更新机制。

**在实际的分布式系统开发中，** 许多RPC框架和服务注册中心也采用了写时复制的设计思想来维护服务路由表。路由表具有典型的读多写少特征，而且对数据一致性的要求相对宽松，这种场景非常适合写时复制模式的应用。

### 2.4 线程本地存储（Thread-Specific Storage） 模式——没有共享就没有伤害

#### 2.4.1 模式介绍

**线程本地存储模式为多线程环境下的数据隔离提供了一种简单而有效的解决方案。** 该模式的核心思想是为每个线程创建独立的数据存储空间，使得每个线程都拥有自己专属的数据副本，从而避免了线程间的数据共享和竞争。

**该模式的基本工作原理如下：**

* **独立存储空间：** 每个线程维护自己独立的数据存储区域

* **数据隔离：** 线程之间无法访问彼此的数据，完全隔离

* **线程绑定：** 数据与特定线程绑定，线程销毁时相关数据自动清理

**在Java标准库中，** ThreadLocal类是实现线程本地存储模式的标准工具类。ThreadLocal为每个使用它的线程提供了独立的变量副本，从而实现了线程安全的数据访问。

**从设计理念的角度分析，** 线程本地存储模式本质上是一种避免共享的并发控制策略。由于没有数据共享，自然也就不存在并发安全问题。这种策略在需要使用线程不安全工具类的并发场景中特别有用。

**当需要在并发环境中使用线程不安全的工具类时，** 有两种主要的解决方案：

* **局部变量方案：** 将工具类对象作为线程栈的局部变量使用，确保每个线程操作独立的实例

* **线程本地存储方案：** 使用ThreadLocal为每个线程维护工具类的独立实例

**相比之下，** 局部变量方案的缺点在于高并发场景下需要频繁创建对象，可能带来额外的性能开销。而线程本地存储方案中，每个线程只需要维护一个工具类实例，避免了频繁创建对象的问题。

#### 2.4.2 使用场景

**线程本地存储模式在并发编程中有着广泛的应用场景，** 特别适合处理需要线程隔离的数据管理需求。以下是一些典型的应用场景：

1. **上下文信息管理：** 在多线程应用中，每个线程可能需要维护自己的执行上下文，包括用户身份、会话信息、事务状态等。线程本地存储为这种上下文信息的隔离管理提供了天然的解决方案
2. **线程安全对象的封装：** 虽然某些对象本身是线程安全的，但在多线程环境中为每个线程维护独立的实例可能更加高效。线程本地存储支持这种实例级别的隔离管理
3. **线程特定行为实现：** 某些应用场景需要在每个线程中实现特定的业务逻辑，如日志跟踪、性能监控、权限控制等。线程本地存储为这些线程特定的行为提供了数据支撑

**从性能优化的角度来看，** 线程本地存储确实能够带来显著的性能提升。然而，这种模式也存在一些需要注意的问题，特别是在内存管理和数据一致性方面。

**特别需要关注的是，** 在线程池环境中使用ThreadLocal时需要格外谨慎。由于线程池中的线程会被重复使用，如果不及时清理ThreadLocal中存储的数据，就可能导致内存泄漏和数据污染问题。

**为了确保ThreadLocal的正确使用，** 应该遵循以下最佳实践：

```java
ExecutorService es;
ThreadLocal tl;

es.execute(()->{
    //ThreadLocal增加变量
    tl.set(obj);
    try {
        // 省略业务逻辑代码
    }finally {
        //手动清理ThreadLocal，避免内存泄漏
        tl.remove();
    }
});
```

**通过在finally块中显式清理ThreadLocal，** 能够有效防止内存泄漏和数据污染，确保线程池环境下的系统稳定性。

## 3. 多线程版本的if模式

**在并发编程的模式分类体系中，** 有一类特殊的模式被称为"多线程版本的if模式"。这类模式的核心特征是通过条件判断来控制线程的执行行为，类似于单线程程序中的if语句，但在多线程环境下具有更加复杂的语义和行为。

**守护挂起模式和避免执行模式是这类模式的典型代表，** 它们通过对执行条件的判断来决定线程的继续执行还是暂停等待。

* **守护挂起模式在实际应用中需要特别注意**性能影响因素

* **避免重复执行模式需要重点关注**竞态条件问题

### 3.1 守护挂起（Guarded Suspension）模式 —— 等我准备好

#### 3.1.1 模式介绍

**守护挂起模式是一种专门用于保护共享资源访问安全的并发设计模式。** 该模式的核心思想是当线程的执行条件不满足时，让线程进入等待状态，直到条件满足后再继续执行。

**在多线程编程实践中，** 为了提高系统的并发性能，通常会将复杂任务分解为多个子任务，交由不同的线程并行执行。然而，在线程间的协作过程中，经常出现一个线程需要等待另一个线程完成特定操作后才能继续执行的情况。

**守护挂起模式正是为了解决这种等待协调问题而设计的。** 该模式允许多个线程访问共享资源，但同时要求资源本身能够对访问请求进行有效的管理和控制。

**从命名和别名的角度来看，** 守护挂起模式有多种称呼，包括：

* **Guarded Suspension：** 正式的英文名称

* **Guarded Wait：** 强调等待特性的别名

* **Spin Lock：** 因使用while循环等待而得名

* **多线程版本的if：** 更加形象的非正式名称

**这种模式的典型应用场景包括：**

* **线程间数据传递：** 当一个线程产生的结果需要传递给另一个线程使用时，可以使用守护挂起模式来协调两个线程的执行

* **持续性数据流处理：** 对于需要在不同线程间持续传递数据的场景，消息队列是更加合适的解决方案

* **同步机制实现：** JDK中的join()方法和FutureTask的实现都采用了守护挂起模式的思想

**从实现机制的角度来看，** 守护挂起模式依赖于Java线程的等待唤醒机制。Java提供了多种等待唤醒机制的实现方式：

* **基础同步机制：** 使用synchronized关键字配合wait()/notify()/notifyAll()方法

* **显式锁机制：** 使用ReentrantLock配合Condition对象的await()/signal()/signalAll()方法

* **现代并发工具：** 使用CAS操作配合LockSupport的park()/unpark()方法

**从底层实现的角度分析，** 这些等待唤醒机制最终都依赖于操作系统提供的线程同步原语，如Linux系统中的pthread\_mutex\_lock/pthread\_mutex\_unlock和pthread\_cond\_wait/pthread\_cond\_signal。

**在复杂的并发系统中，** 线程间的协作和通信是不可避免的，因此等待唤醒机制是并发编程的基础和核心。

#### 3.1.2 使用场景

* **从适用条件的角度分析，** 守护挂起模式特别适合以下场景：多个线程同时访问同一个共享资源实例，需要从资源实例中获取资源并进行处理

* **从资源管理的角度考虑，** 该模式适用于资源实例需要自主管理自身资源分配，并对请求线程的访问请求进行判断和控制的情况

#### 3.1.3 守护挂起模式的实现：GuradedObject为例

**下面的代码示例展示了一个典型的守护挂起模式实现：**

```java
public class GuardedObject<T> {
    //结果
    private T obj;

    //获取结果
    public T get(){
        // 确保线程安全
        synchronized (this){
            //没有结果等待，用while防止虚假唤醒
            while (obj==null){
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return obj;
        }
    }

    //产生结果
    public void complete(T obj){
        // 确保线程安全
        synchronized (this){
            //获取到结果，给obj赋值
            this.obj = obj;
            //唤醒等待结果的线程
            this.notifyAll();
        }
    }
}
```

**这个实现的关键特点包括：**

* **使用synchronized保证线程安全：** 通过对象锁确保对共享状态访问的原子性

* **while循环防止虚假唤醒：** 使用while而不是if来检查条件，防止因虚假唤醒而导致的问题

* **wait()/notifyAll()协调线程执行：** 通过等待唤醒机制实现线程间的协调

* **泛型设计支持多种数据类型：** 使用泛型使得该工具类能够处理各种类型的结果对象

### 3.2 避免执行（Balking）模式——不需要就算了

#### 3.2.1 模式介绍

**Balking模式的字面含义是"退缩不前"或"拒绝执行"。** 该模式的核心思想是：当执行某个操作的条件不再满足时，直接放弃执行并返回，而不进行任何等待或重试。

**从应用场景的特征来看，** 当流程的执行依赖于某个共享变量的状态时，Balking模式提供了一种高效的执行控制策略。该模式特别适用于多个线程可能执行相同操作的场景，其中某个线程的操作可能使得其他线程的操作变得不再必要。

**从模式特性的角度分析，** Balking模式具有以下显著特点：

* **条件驱动的执行控制：** 基于特定条件的判断来决定是否执行操作

* **无等待机制：** 当条件不满足时，直接放弃执行而不进入等待状态

* **执行效率优化：** 避免了不必要的重复操作，提高了整体执行效率

**与守护挂起模式的对比来看，** 虽然两种模式都涉及守护条件的检查，但在处理方式上存在根本性的差异：

* **守护挂起模式：** 当条件不满足时，线程进入等待状态直到条件满足

* **Balking模式：** 当条件不满足时，线程直接放弃执行并返回

**这种差异使得两种模式适用于不同的应用场景。** Balking模式更加注重执行效率，而守护挂起模式更加注重操作的完整性。

#### 3.2.2 使用场景

**Balking模式在实际软件开发中有着广泛的应用，** 特别是在需要避免重复执行和资源浪费的场景中。以下是一些典型的应用实例：

* **轻量级锁的膨胀机制：** 在Java synchronized锁的实现中，轻量级锁向重量级锁的膨胀过程只需要一个线程来完成，其他线程可以跳过这个过程

* **双重检查锁定单例模式：** 在单例模式的实现中，使用双重检查锁定来避免多次创建实例

* **服务组件的初始化：** 在系统启动过程中，确保某些服务组件只被初始化一次

#### 3.2.3 如何实现Balking模式

##### (1) 介绍

**Balking模式的实现有多种技术方案，** 可以根据具体的应用场景和性能要求选择合适的实现方式：

* **基于锁的实现：** 使用synchronized关键字或ReentrantLock来实现条件检查和执行的原子性

* **基于CAS的实现：** 使用CompareAndSwap原子操作来实现无锁的条件检查和状态更新

* **基于volatile的实现：** 对于不要求原子性检查的场景，可以使用volatile变量来实现轻量级的实现

##### (2) 例子1：快速存盘

**文本编辑器的自动保存功能是Balking模式的经典应用场景。** 在这个场景中，编辑器需要定期检查文件是否发生了修改，只有当文件确实被修改时才执行保存操作。

```java
boolean changed = false;

// 自动存盘操作
void autoSave() {
    synchronized (this) {
        if (!changed) {
            return;
        }
        changed = false;
    }
    // 执行存盘操作
    // 省略且实现
    this.execSave();
}

// 编辑操作
void edit() {
    // 省略编辑逻辑
    ......
    change();
}

// 改变状态
void change() {
    synchronized (this) {
        changed = true;
    }
}
```

该功能的实现逻辑包含以下关键步骤：**

* **修改状态跟踪：** 使用布尔变量跟踪文件是否被修改

* **条件检查：** 在执行保存前检查文件修改状态

* **条件不满足时的快速退出：** 如果文件未被修改，直接放弃保存操作

* **状态重置：** 保存完成后重置修改状态标志

**这种实现方式有效避免了不必要的磁盘I/O操作，** 提高了编辑器的响应性能。

##### (3) 例子2：单次初始化

**Balking模式在组件初始化场景中有着重要的应用价值。** 在许多系统中，某些组件或资源只需要初始化一次，多次初始化不仅浪费资源，还可能导致系统状态异常。

```java
boolean inited = false;

synchronized void init() {
    if (inited) {
        return;
    }
    // 省略 doInit 的实现
    doInit();
    inited = true;
}
```

**单次初始化的实现需要注意以下几点：**

* **初始化状态跟踪：** 使用状态变量记录初始化的完成情况

* **初始化前的条件检查：** 在执行初始化前检查是否已经完成初始化，即常用的双重检查

* **初始化操作的同步控制：** 确保初始化操作的线程安全性，例如synchronized

* **异常处理：** 妥善处理初始化过程中可能出现的异常情况

**通过Balking模式的应用，** 可以有效确保组件的单次初始化，避免重复初始化带来的资源浪费和状态混乱。

## 4. 多线程分工模式

**在并发编程的模式体系中，** 多线程分工模式主要关注如何有效地组织和分配任务到不同的线程中执行。这类模式的核心目标是通过合理的任务分配和线程协调，提高系统的并发性能和资源利用率。

**Worker Thread模式和生产者-消费者模式是分工模式的主要代表。** 它们都体现了将任务分解到不同线程中执行的核心思想，但在具体的实现方式和适用场景上有所不同。

**在实际应用这些模式时，** 需要特别关注以下关键问题：

* **线程生命周期管理：** 线程的创建、销毁和资源回收过程

* **资源利用效率：** 避免线程数量过多导致的资源耗尽和性能下降

* **任务依赖关系管理：** 避免任务间的依赖关系导致的死锁问题

**从实现技术的角度来看，** 生产者-消费者模式可以直接使用Java线程池来实现，这为该模式的应用提供了便利的技术支撑。

### 4.1 Thread-Per-Message 模式 —— 最简单实用的分工方法

#### 4.1.1 模式介绍

**Thread-Per-Message模式是并发编程中最简单直观的分工方法。** 该模式的核心思想是为每个任务分配一个独立的线程，通过线程的并行执行来提高系统的并发处理能力。

**从设计哲学的角度来看，** Thread-Per-Message模式体现了"一任务一线程"的简单理念。每个消息或任务都对应一个专门的执行线程，线程完成执行后自动销毁。这种设计的优点在于实现简单，逻辑清晰。

#### 4.1.2 应用场景

**Thread-Per-Message模式最经典的应用场景是在网络编程的服务端实现中。** 在Web服务器、应用服务器等网络服务中，每个客户端的连接请求都需要独立处理，而Thread-Per-Message模式正好满足这种需求。

**具体而言，** 服务端为每个客户端连接创建一个独立的处理线程，该线程专门负责处理该客户端的所有请求。当客户端断开连接或所有请求处理完成后，对应的线程也随之销毁。这种模式为并发处理网络请求提供了最直接的解决方案。

**下面的代码展示了Thread-Per-Message模式的基本实现：**

```java
final ServerSocketChannel ssc = ServerSocketChannel.open().bind(new InetSocketAddress(8080));

//处理请求
try {
    while (true) {
        // 接收请求
        SocketChannel sc = ssc.accept();

        // 每个请求都创建一个线程 （Java线程的成本很重，成本极高）
        new Thread(()->{
            try {
                // 读Socket
                ByteBuffer rb = ByteBuffer.allocateDirect(1024);
                sc.read(rb);

                //模拟处理请求
                Thread.sleep(2000);

                // 写Socket
                ByteBuffer wb = (ByteBuffer)rb.flip();
                sc.write(wb);

                // 关闭Socket
                sc.close();
            } catch(Exception e){
                throw new UncheckedIOException(e);
            }
        }).start();
    }
} finally {
    ssc.close();
}
```

**从性能分析的角度来看，** Thread-Per-Message模式虽然实现简单，但在Java环境中存在明显的性能限制。主要原因是Java中的线程是重量级对象，创建和销毁的成本相对较高：

* **创建开销大：** 线程的创建过程涉及内存分配、数据结构初始化等操作，耗时较长

* **内存占用多：** 每个线程都需要独立的栈空间和相关的数据结构，内存开销较大

* **资源限制：** 系统能够创建的线程数量受到内存和CPU资源的限制

**这些限制使得Thread-Per-Message模式不适合高并发场景。** 为了解决这些问题，Java并发包提供了**线程池**等更加高效的线程管理工具。

**值得注意的是，** 在其他编程语言中，如Go语言，由于其采用了**轻量级线程（goroutine）**的设计，Thread-Per-Message模式的应用效果要好得多。这说明了语言特性对设计模式适用性的重要影响。

**对于并发度要求不高的异步场景，** 如定时任务处理、后台作业执行等，Thread-Per-Message模式仍然是一个可行且合理的选择。

### 4.2 Worker Thread模式 ——  如何避免重复创建线程

**Worker Thread模式是为了解决Thread-Per-Message模式的性能问题而发展起来的。** 该模式通过复用固定数量的工作线程来处理大量的并发任务，有效避免了频繁创建和销毁线程带来的性能开销。

**为了更好地理解Worker Thread模式，** 可以将其与现实世界中的车间工作模式进行类比。在工厂车间里，有固定数量的工人，有任务时大家一起工作，没有任务时就等待新的任务分配。Worker Thread模式中的工作线程就类似于车间里的工人。

#### 4.2.1 Worker Thread 模式实现：Thread Pool

**Worker Thread模式最经典的实现方式就是线程池。** 线程池预先创建固定数量的工作线程，这些线程持续地从任务队列中获取任务并执行。

**下面的代码展示了使用线程池实现的服务端程序：**

```java
ExecutorService es = Executors.newFixedThreadPool(200);
final ServerSocketChannel ssc = ServerSocketChannel.open().bind(new InetSocketAddress(8080));

//处理请求
try {
    while (true) {
        // 接收请求
        SocketChannel sc = ssc.accept();

        // 将请求处理任务提交给线程池
        es.execute(()->{
            try {
                // 读Socket
                ByteBuffer rb = ByteBuffer.allocateDirect(1024);
                sc.read(rb);

                //模拟处理请求
                Thread.sleep(2000);

                // 写Socket
                ByteBuffer wb = (ByteBuffer)rb.flip();
                sc.write(wb);

                // 关闭Socket
                sc.close();
            }catch(Exception e){
                throw new UncheckedIOException(e);
            }
        });
    }
} finally {
    ssc.close();
    es.shutdown();
}
```

**这个实现的关键特点包括：**

* **固定数量的工作线程：** 通过线程池维护固定数量的工作线程，避免线程数量的无限增长

* **任务队列缓冲：** 使用任务队列来缓存待处理的任务，平滑处理任务到达的波动

* **线程复用：** 工作线程可以重复使用来处理多个任务，大大提高了资源利用率

* **优雅关闭：** 提供了规范的线程池关闭机制，确保所有任务完成后才释放资源

#### 4.2.2 应用场景

**Worker Thread模式的优势使其在现代Java应用开发中得到广泛应用：**

* **避免频繁创建销毁：** 通过线程复用机制，避免了Thread-Per-Message模式中频繁创建和销毁线程的开销

* **资源可控：** 通过限制线程的最大数量，有效控制系统资源的使用，避免资源耗尽

* **性能优化：** 线程池作为Java并发包的基础工具类，经过了大量的性能优化和测试验证

**在实际的企业级开发中，** 许多公司的编码规范都明确要求使用线程池而不是手动创建线程。这不仅是性能考虑，也是代码规范性和可维护性的要求。

### 4.3 生产者 - 消费者模式——用流水线的思想提高效率

**生产者-消费者模式借鉴了现实世界中流水线工作模式的思想。** 如果说Worker Thread模式类似于车间里工人并行工作的场景，那么生产者-消费者模式则更像是工厂里的流水线作业。

**该模式的核心架构包含三个主要组件：**

* **生产者线程：** 负责创建和产生任务

* **任务队列：** 作为生产者和消费者之间的缓冲区

* **消费者线程：** 负责执行任务

**通过这种解耦的设计，** 生产者和消费者可以独立地工作，不需要直接交互，大大提高了系统的灵活性和可扩展性。

**下面的代码展示了一个典型的生产者-消费者模式实现：**

```java
public class BlockingQueueExample {
    private static final int QUEUE_CAPACITY = 5;
    private static final int PRODUCER_DELAY_MS = 1000;
    private static final int CONSUMER_DELAY_MS = 2000;

    public static void main(String[] args) throws InterruptedException {
        // 创建一个容量为QUEUE_CAPACITY的阻塞队列
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(QUEUE_CAPACITY);

        // 创建一个生产者线程
        Runnable producer = () -> {
            while (true) {
                try {
                    queue.put("producer");  // 在队列满时会阻塞
                    System.out.println("生产了一个元素，队列中元素个数：" + queue.size());
                    Thread.sleep(PRODUCER_DELAY_MS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        new Thread(producer).start();

        // 创建一个消费者线程
        Runnable consumer = () -> {
            while (true) {
                try {
                    String element = queue.take(); //队列空时会阻塞
                    System.out.println("消费了一个元素，队列中元素个数：" + queue.size());
                    Thread.sleep(CONSUMER_DELAY_MS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        new Thread(consumer).start();
    }
}
```

#### 4.3.1 生产者 - 消费者模式的优点

**支持异步处理**

**以用户注册场景为例，** 传统的实现方式存在明显的性能瓶颈：

* **串行处理方式：** 用户注册完成后，依次发送注册邮件和注册短信，总耗时是两者之和

* **并行处理方式：** 用户注册完成后，并行发送邮件和短信，总耗时是两者中的较大值

**通过引入消息队列，** 可以将邮件发送、短信发送等非核心业务逻辑异步处理，从而大幅提升用户注册的响应速度。

**解耦**

**在电商系统的订单处理场景中，** 用户下单后，订单系统需要通知库存系统扣减库存。如果没有消息队列，订单系统需要直接调用库存系统的接口，存在以下问题：

* **系统紧耦合：** 订单系统和库存系统紧密耦合，一方变更会影响另一方

* **可用性问题：** 库存系统不可用时，订单系统也会受到影响

**通过消息队列的引入，** 订单系统只需要将库存扣减消息发送到队列中，库存系统异步处理这些消息，实现了系统的解耦。

**可以消除生产者生产与消费者消费之间速度差异**

**从系统性能的角度来看，** 并发环境中线程数量并非越多越好。过多的线程会导致CPU上下文切换频繁，反而降低系统性能。生产者-消费者模式通过固定数量的消费者线程来处理任务，实现了线程数量的合理控制。

**从系统缓冲的角度来看，** 任务队列在系统中起到了重要的缓冲作用。当生产者的生产速度超过消费者的消费速度时，任务会在队列中积累，这实际上就是系统削峰填谷的作用。这种机制在处理突发流量时特别有价值。

#### 4.3.2 过饱问题解决方案

##### (1) 介绍

**在实际的生产环境中，** 生产者-消费者模式可能面临过饱问题。过饱问题指的是单位时间内生产者产生的任务数量超过了消费者的处理能力，导致任务在队列中不断积累，最终可能耗尽队列容量。

**从问题分析的角度来看，** 解决过饱问题需要综合考虑多个因素：

* **消费者处理能力：** 消费者单位时间内能够处理的任务数量

* **生产者生产速率：** 生产者单位时间内产生的任务数量

* **队列容量限制：** 任务队列的最大容量

* **业务响应时间要求：** 业务允许的任务最长处理时间

**从业务需求的角度分析，** 过饱问题的判断标准不应该是简单的"消费者速度必须超过生产者速度"，而应该是"消费者必须在业务容忍的最长响应时间内处理完堆积的任务"。

**业务容忍的最长响应时间是指业务能够接受的任务处理延迟。** 例如，在数据统计系统中，前一天的数据需要在第二天开始前完成处理并生成报表。如果前一天的数据到第二天下午还未处理完成，就不符合业务要求。

**针对不同的应用场景，** 需要采用不同的解决方案：

##### (2) 场景分析与解决方案

**场景一：消费者处理能力不足**

* **问题描述：** 消费者每天能处理的任务数量（如5000条）少于生产者产生的任务数量（如10000条）

* **解决方案：** 增加消费者实例数量，即水平扩展消费者

* **原因分析：** 由于业务要求必须在规定时间内完成所有任务，生产者无法进行限流，只能通过增加消费者来提升整体处理能力

**场景二：队列容量不足**

* **问题描述：** 消费者每天的处理能力（12000条）超过生产者的产量（10000条），但系统高峰期生产速度过快，导致队列被塞满

* **解决方案：** 适当增加队列容量

* **原因分析：** 由于消费者整体处理能力足够，只要避免高峰期队列溢出即可，增加队列容量是最直接的解决方案

**场景三：资源受限无法扩展队列**

* **问题描述：** 消费者处理能力足够，但由于内存等资源限制，无法设置足够大的队列容量，高峰期仍然出现队列溢出

* **解决方案：** 对生产者进行限流

* **原因分析：** 在队列容量无法扩大的情况下，只能通过控制生产速度来避免队列溢出

**这些解决方案的选择需要基于具体的业务场景、系统资源和性能要求来综合考虑。**
